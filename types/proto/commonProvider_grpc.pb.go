// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.1
// source: proto/commonProvider.proto

package commonProviderpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CryptoProviderService_CreateCryptoContext_FullMethodName     = "/crypto.provider.CryptoProviderService/CreateCryptoContext"
	CryptoProviderService_DestroyCryptoContext_FullMethodName    = "/crypto.provider.CryptoProviderService/DestroyCryptoContext"
	CryptoProviderService_IsCryptoContextExisting_FullMethodName = "/crypto.provider.CryptoProviderService/IsCryptoContextExisting"
	CryptoProviderService_GetNamespaces_FullMethodName           = "/crypto.provider.CryptoProviderService/GetNamespaces"
	CryptoProviderService_GenerateRandom_FullMethodName          = "/crypto.provider.CryptoProviderService/GenerateRandom"
	CryptoProviderService_Hash_FullMethodName                    = "/crypto.provider.CryptoProviderService/Hash"
	CryptoProviderService_Encrypt_FullMethodName                 = "/crypto.provider.CryptoProviderService/Encrypt"
	CryptoProviderService_Decrypt_FullMethodName                 = "/crypto.provider.CryptoProviderService/Decrypt"
	CryptoProviderService_Sign_FullMethodName                    = "/crypto.provider.CryptoProviderService/Sign"
	CryptoProviderService_Verify_FullMethodName                  = "/crypto.provider.CryptoProviderService/Verify"
	CryptoProviderService_GetKeys_FullMethodName                 = "/crypto.provider.CryptoProviderService/GetKeys"
	CryptoProviderService_GetKey_FullMethodName                  = "/crypto.provider.CryptoProviderService/GetKey"
	CryptoProviderService_GenerateKey_FullMethodName             = "/crypto.provider.CryptoProviderService/GenerateKey"
	CryptoProviderService_IsKeyExisting_FullMethodName           = "/crypto.provider.CryptoProviderService/IsKeyExisting"
	CryptoProviderService_DeleteKey_FullMethodName               = "/crypto.provider.CryptoProviderService/DeleteKey"
	CryptoProviderService_RotateKey_FullMethodName               = "/crypto.provider.CryptoProviderService/RotateKey"
	CryptoProviderService_GetSupportedKeysAlgs_FullMethodName    = "/crypto.provider.CryptoProviderService/GetSupportedKeysAlgs"
	CryptoProviderService_GetSupportedHashAlgs_FullMethodName    = "/crypto.provider.CryptoProviderService/GetSupportedHashAlgs"
)

// CryptoProviderServiceClient is the client API for CryptoProviderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptoProviderServiceClient interface {
	// Context Lifecycle
	CreateCryptoContext(ctx context.Context, in *CreateContextRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	DestroyCryptoContext(ctx context.Context, in *DestroyContextRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	IsCryptoContextExisting(ctx context.Context, in *IsContextExistingRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Operations requiring an existing context
	GetNamespaces(ctx context.Context, in *GetNamespacesRequest, opts ...grpc.CallOption) (*NamespacesResponse, error)
	GenerateRandom(ctx context.Context, in *GenerateRandomRequest, opts ...grpc.CallOption) (*RandomResponse, error)
	Hash(ctx context.Context, in *HashRequest, opts ...grpc.CallOption) (*HashResponse, error)
	Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error)
	Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error)
	Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error)
	Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	GetKeys(ctx context.Context, in *GetKeysRequest, opts ...grpc.CallOption) (*GetKeysResponse, error)
	GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResponse, error)
	GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	IsKeyExisting(ctx context.Context, in *IsKeyExistingRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	DeleteKey(ctx context.Context, in *DeleteKeyRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	RotateKey(ctx context.Context, in *RotateKeyRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	GetSupportedKeysAlgs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SupportedKeyTypesResponse, error)
	GetSupportedHashAlgs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SupportedHashTypesResponse, error)
}

type cryptoProviderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptoProviderServiceClient(cc grpc.ClientConnInterface) CryptoProviderServiceClient {
	return &cryptoProviderServiceClient{cc}
}

func (c *cryptoProviderServiceClient) CreateCryptoContext(ctx context.Context, in *CreateContextRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_CreateCryptoContext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) DestroyCryptoContext(ctx context.Context, in *DestroyContextRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_DestroyCryptoContext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) IsCryptoContextExisting(ctx context.Context, in *IsContextExistingRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_IsCryptoContextExisting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) GetNamespaces(ctx context.Context, in *GetNamespacesRequest, opts ...grpc.CallOption) (*NamespacesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NamespacesResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_GetNamespaces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) GenerateRandom(ctx context.Context, in *GenerateRandomRequest, opts ...grpc.CallOption) (*RandomResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RandomResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_GenerateRandom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) Hash(ctx context.Context, in *HashRequest, opts ...grpc.CallOption) (*HashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HashResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_Hash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_Encrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_Decrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_Sign_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_Verify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) GetKeys(ctx context.Context, in *GetKeysRequest, opts ...grpc.CallOption) (*GetKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetKeysResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_GetKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetKeyResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_GetKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_GenerateKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) IsKeyExisting(ctx context.Context, in *IsKeyExistingRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_IsKeyExisting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) DeleteKey(ctx context.Context, in *DeleteKeyRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_DeleteKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) RotateKey(ctx context.Context, in *RotateKeyRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_RotateKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) GetSupportedKeysAlgs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SupportedKeyTypesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SupportedKeyTypesResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_GetSupportedKeysAlgs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoProviderServiceClient) GetSupportedHashAlgs(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SupportedHashTypesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SupportedHashTypesResponse)
	err := c.cc.Invoke(ctx, CryptoProviderService_GetSupportedHashAlgs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CryptoProviderServiceServer is the server API for CryptoProviderService service.
// All implementations must embed UnimplementedCryptoProviderServiceServer
// for forward compatibility.
type CryptoProviderServiceServer interface {
	// Context Lifecycle
	CreateCryptoContext(context.Context, *CreateContextRequest) (*BoolResponse, error)
	DestroyCryptoContext(context.Context, *DestroyContextRequest) (*BoolResponse, error)
	IsCryptoContextExisting(context.Context, *IsContextExistingRequest) (*BoolResponse, error)
	// Operations requiring an existing context
	GetNamespaces(context.Context, *GetNamespacesRequest) (*NamespacesResponse, error)
	GenerateRandom(context.Context, *GenerateRandomRequest) (*RandomResponse, error)
	Hash(context.Context, *HashRequest) (*HashResponse, error)
	Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error)
	Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error)
	Sign(context.Context, *SignRequest) (*SignResponse, error)
	Verify(context.Context, *VerifyRequest) (*VerifyResponse, error)
	GetKeys(context.Context, *GetKeysRequest) (*GetKeysResponse, error)
	GetKey(context.Context, *GetKeyRequest) (*GetKeyResponse, error)
	GenerateKey(context.Context, *GenerateKeyRequest) (*BoolResponse, error)
	IsKeyExisting(context.Context, *IsKeyExistingRequest) (*BoolResponse, error)
	DeleteKey(context.Context, *DeleteKeyRequest) (*BoolResponse, error)
	RotateKey(context.Context, *RotateKeyRequest) (*BoolResponse, error)
	GetSupportedKeysAlgs(context.Context, *Empty) (*SupportedKeyTypesResponse, error)
	GetSupportedHashAlgs(context.Context, *Empty) (*SupportedHashTypesResponse, error)
	mustEmbedUnimplementedCryptoProviderServiceServer()
}

// UnimplementedCryptoProviderServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCryptoProviderServiceServer struct{}

func (UnimplementedCryptoProviderServiceServer) CreateCryptoContext(context.Context, *CreateContextRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCryptoContext not implemented")
}
func (UnimplementedCryptoProviderServiceServer) DestroyCryptoContext(context.Context, *DestroyContextRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyCryptoContext not implemented")
}
func (UnimplementedCryptoProviderServiceServer) IsCryptoContextExisting(context.Context, *IsContextExistingRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsCryptoContextExisting not implemented")
}
func (UnimplementedCryptoProviderServiceServer) GetNamespaces(context.Context, *GetNamespacesRequest) (*NamespacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNamespaces not implemented")
}
func (UnimplementedCryptoProviderServiceServer) GenerateRandom(context.Context, *GenerateRandomRequest) (*RandomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateRandom not implemented")
}
func (UnimplementedCryptoProviderServiceServer) Hash(context.Context, *HashRequest) (*HashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Hash not implemented")
}
func (UnimplementedCryptoProviderServiceServer) Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (UnimplementedCryptoProviderServiceServer) Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}
func (UnimplementedCryptoProviderServiceServer) Sign(context.Context, *SignRequest) (*SignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sign not implemented")
}
func (UnimplementedCryptoProviderServiceServer) Verify(context.Context, *VerifyRequest) (*VerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedCryptoProviderServiceServer) GetKeys(context.Context, *GetKeysRequest) (*GetKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeys not implemented")
}
func (UnimplementedCryptoProviderServiceServer) GetKey(context.Context, *GetKeyRequest) (*GetKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKey not implemented")
}
func (UnimplementedCryptoProviderServiceServer) GenerateKey(context.Context, *GenerateKeyRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateKey not implemented")
}
func (UnimplementedCryptoProviderServiceServer) IsKeyExisting(context.Context, *IsKeyExistingRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsKeyExisting not implemented")
}
func (UnimplementedCryptoProviderServiceServer) DeleteKey(context.Context, *DeleteKeyRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKey not implemented")
}
func (UnimplementedCryptoProviderServiceServer) RotateKey(context.Context, *RotateKeyRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RotateKey not implemented")
}
func (UnimplementedCryptoProviderServiceServer) GetSupportedKeysAlgs(context.Context, *Empty) (*SupportedKeyTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSupportedKeysAlgs not implemented")
}
func (UnimplementedCryptoProviderServiceServer) GetSupportedHashAlgs(context.Context, *Empty) (*SupportedHashTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSupportedHashAlgs not implemented")
}
func (UnimplementedCryptoProviderServiceServer) mustEmbedUnimplementedCryptoProviderServiceServer() {}
func (UnimplementedCryptoProviderServiceServer) testEmbeddedByValue()                               {}

// UnsafeCryptoProviderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptoProviderServiceServer will
// result in compilation errors.
type UnsafeCryptoProviderServiceServer interface {
	mustEmbedUnimplementedCryptoProviderServiceServer()
}

func RegisterCryptoProviderServiceServer(s grpc.ServiceRegistrar, srv CryptoProviderServiceServer) {
	// If the following call pancis, it indicates UnimplementedCryptoProviderServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CryptoProviderService_ServiceDesc, srv)
}

func _CryptoProviderService_CreateCryptoContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateContextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).CreateCryptoContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_CreateCryptoContext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).CreateCryptoContext(ctx, req.(*CreateContextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_DestroyCryptoContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyContextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).DestroyCryptoContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_DestroyCryptoContext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).DestroyCryptoContext(ctx, req.(*DestroyContextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_IsCryptoContextExisting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsContextExistingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).IsCryptoContextExisting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_IsCryptoContextExisting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).IsCryptoContextExisting(ctx, req.(*IsContextExistingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_GetNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNamespacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).GetNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_GetNamespaces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).GetNamespaces(ctx, req.(*GetNamespacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_GenerateRandom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateRandomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).GenerateRandom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_GenerateRandom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).GenerateRandom(ctx, req.(*GenerateRandomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_Hash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).Hash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_Hash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).Hash(ctx, req.(*HashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_Encrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).Encrypt(ctx, req.(*EncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_Decrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).Decrypt(ctx, req.(*DecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_Sign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).Sign(ctx, req.(*SignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_Verify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).Verify(ctx, req.(*VerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_GetKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).GetKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_GetKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).GetKeys(ctx, req.(*GetKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_GetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).GetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_GetKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).GetKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_GenerateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).GenerateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_GenerateKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).GenerateKey(ctx, req.(*GenerateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_IsKeyExisting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsKeyExistingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).IsKeyExisting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_IsKeyExisting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).IsKeyExisting(ctx, req.(*IsKeyExistingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_DeleteKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).DeleteKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_DeleteKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).DeleteKey(ctx, req.(*DeleteKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_RotateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RotateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).RotateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_RotateKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).RotateKey(ctx, req.(*RotateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_GetSupportedKeysAlgs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).GetSupportedKeysAlgs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_GetSupportedKeysAlgs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).GetSupportedKeysAlgs(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoProviderService_GetSupportedHashAlgs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoProviderServiceServer).GetSupportedHashAlgs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CryptoProviderService_GetSupportedHashAlgs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoProviderServiceServer).GetSupportedHashAlgs(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// CryptoProviderService_ServiceDesc is the grpc.ServiceDesc for CryptoProviderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CryptoProviderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crypto.provider.CryptoProviderService",
	HandlerType: (*CryptoProviderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCryptoContext",
			Handler:    _CryptoProviderService_CreateCryptoContext_Handler,
		},
		{
			MethodName: "DestroyCryptoContext",
			Handler:    _CryptoProviderService_DestroyCryptoContext_Handler,
		},
		{
			MethodName: "IsCryptoContextExisting",
			Handler:    _CryptoProviderService_IsCryptoContextExisting_Handler,
		},
		{
			MethodName: "GetNamespaces",
			Handler:    _CryptoProviderService_GetNamespaces_Handler,
		},
		{
			MethodName: "GenerateRandom",
			Handler:    _CryptoProviderService_GenerateRandom_Handler,
		},
		{
			MethodName: "Hash",
			Handler:    _CryptoProviderService_Hash_Handler,
		},
		{
			MethodName: "Encrypt",
			Handler:    _CryptoProviderService_Encrypt_Handler,
		},
		{
			MethodName: "Decrypt",
			Handler:    _CryptoProviderService_Decrypt_Handler,
		},
		{
			MethodName: "Sign",
			Handler:    _CryptoProviderService_Sign_Handler,
		},
		{
			MethodName: "Verify",
			Handler:    _CryptoProviderService_Verify_Handler,
		},
		{
			MethodName: "GetKeys",
			Handler:    _CryptoProviderService_GetKeys_Handler,
		},
		{
			MethodName: "GetKey",
			Handler:    _CryptoProviderService_GetKey_Handler,
		},
		{
			MethodName: "GenerateKey",
			Handler:    _CryptoProviderService_GenerateKey_Handler,
		},
		{
			MethodName: "IsKeyExisting",
			Handler:    _CryptoProviderService_IsKeyExisting_Handler,
		},
		{
			MethodName: "DeleteKey",
			Handler:    _CryptoProviderService_DeleteKey_Handler,
		},
		{
			MethodName: "RotateKey",
			Handler:    _CryptoProviderService_RotateKey_Handler,
		},
		{
			MethodName: "GetSupportedKeysAlgs",
			Handler:    _CryptoProviderService_GetSupportedKeysAlgs_Handler,
		},
		{
			MethodName: "GetSupportedHashAlgs",
			Handler:    _CryptoProviderService_GetSupportedHashAlgs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/commonProvider.proto",
}
